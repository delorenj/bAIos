#!/usr/bin/env python3
"""
Shelldon - Shell scripting and command-line expert.

Shelldon specializes in shell scripting, command-line tools, system administration,
and terminal workflows. He knows all the ins and outs of bash, zsh, and other shells.
"""

from .base import Agent
from typing import Dict, Any
import os
import subprocess
from pathlib import Path


class Shelldon(Agent):
    """
    Shelldon specializes in:
    - Shell scripting (bash, zsh, fish, etc.)
    - Command-line tools and utilities  
    - System administration tasks
    - Terminal configuration and customization
    - Process management and system monitoring
    """
    
    def __init__(self):
        super().__init__(
            name="Shelldon",
            expertise="Shell scripting, command-line tools, and terminal workflows",
            personality="Command-line wizard with deep system knowledge. Speaks in precise, efficient commands and loves elegant one-liners."
        )
    
    def handle_script_request(self, question: str, script_type: str, 
                            suggested_filename: str) -> str:
        """
        Handle script creation requests for Shelldon.
        
        Args:
            question: Original question from user
            script_type: Type of script detected (python, bash, etc.)
            suggested_filename: Suggested filename for the script
            
        Returns:
            Response about script creation
        """
        question_lower = question.lower()
        
        # Generate script content based on the request
        if 'hello' in question_lower or 'print' in question_lower:
            # Simple hello world scripts
            if script_type == 'python':
                content = '''#!/usr/bin/env python3
# Generated by Shelldon - bAIos CLI Agent

print('Hello from Shelldon!')
print('I am your command-line assistant.')
print('Created with bAIos agent system.')
'''
                description = "Simple Python script that prints a greeting from Shelldon"
            elif script_type == 'bash':
                content = '''#!/bin/bash
# Generated by Shelldon - bAIos CLI Agent

echo "Hello from Shelldon!"
echo "I am your command-line assistant."
echo "Created with bAIos agent system."
'''
                description = "Simple Bash script that prints a greeting from Shelldon"
            else:
                content = f"Hello from Shelldon!\nScript type: {script_type}\nCreated with bAIos agent system."
                description = f"Simple {script_type} script from Shelldon"
        
        elif 'system' in question_lower and 'info' in question_lower:
            # System information script
            if script_type == 'python':
                content = '''#!/usr/bin/env python3
# System Information Script by Shelldon

import platform
import os
import socket
import datetime

print("="*50)
print("System Information - Generated by Shelldon")
print("="*50)
print(f"Hostname: {socket.gethostname()}")
print(f"Platform: {platform.system()} {platform.release()}")
print(f"Architecture: {platform.machine()}")
print(f"Python Version: {platform.python_version()}")
print(f"Current User: {os.environ.get('USER', 'Unknown')}")
print(f"Current Directory: {os.getcwd()}")
print(f"Generated: {datetime.datetime.now()}")
print("="*50)
'''
                description = "Python script to display system information"
            else:
                content = '''#!/bin/bash
# System Information Script by Shelldon

echo "================================================"
echo "System Information - Generated by Shelldon"
echo "================================================"
echo "Hostname: $(hostname)"
echo "Platform: $(uname -s) $(uname -r)"
echo "Architecture: $(uname -m)"
echo "Current User: $USER"
echo "Current Directory: $(pwd)"
echo "Generated: $(date)"
echo "================================================"
'''
                description = "Bash script to display system information"
        
        else:
            # Generic useful script based on type
            if script_type == 'python':
                content = '''#!/usr/bin/env python3
"""\nScript generated by Shelldon - bAIos CLI Agent\nCustomize this template for your needs\n"""

import sys
import os
from pathlib import Path

def main():
    """Main function"""
    print("Shelldon's Python Script Template")
    print("-" * 40)
    
    # Your code here
    print(f"Working directory: {Path.cwd()}")
    print(f"Script location: {Path(__file__).resolve()}")
    print(f"Python version: {sys.version}")
    
    # Example: Process command line arguments
    if len(sys.argv) > 1:
        print(f"\nArguments received: {sys.argv[1:]}")
    
    return 0

if __name__ == "__main__":
    sys.exit(main())
'''
                description = "Python script template with common patterns"
            
            elif script_type == 'bash':
                content = '''#!/bin/bash
# Script generated by Shelldon - bAIos CLI Agent
# Customize this template for your needs

set -euo pipefail  # Exit on error, undefined vars, pipe failures

# Color output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Script info
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SCRIPT_NAME="$(basename "$0")"

# Function for logging
log() {
    echo -e "${GREEN}[$(date +'%Y-%m-%d %H:%M:%S')]${NC} $*"
}

error() {
    echo -e "${RED}[ERROR]${NC} $*" >&2
}

warning() {
    echo -e "${YELLOW}[WARNING]${NC} $*"
}

# Main function
main() {
    log "Shelldon's Bash Script Template"
    log "Script location: $SCRIPT_DIR/$SCRIPT_NAME"
    log "Working directory: $(pwd)"
    
    # Your code here
    if [[ $# -gt 0 ]]; then
        log "Arguments received: $*"
    fi
    
    log "Script completed successfully!"
}

# Run main function
main "$@"
'''
                description = "Bash script template with error handling and logging"
            
            else:
                content = f"# Script generated by Shelldon\n# Type: {script_type}\n# Add your code here\n"
                description = f"{script_type} script template"
        
        # Write the script to filesystem
        success, filepath = self.write_script(content, suggested_filename, description)
        
        # Format response
        if success:
            response = f"üêö **Shelldon** created your script!\n\n"
            response += self.format_script_response(success, filepath, content)
            response += f"\nüí° **Script Details:**\n"
            response += f"- Type: {script_type}\n"
            response += f"- Purpose: {description}\n"
            response += f"\nüéØ **Next Steps:**\n"
            response += f"1. Review the script at `{filepath}`\n"
            response += f"2. Modify as needed for your specific use case\n"
            response += f"3. Run it using the commands above\n"
            response += f"\nüöÄ Need help customizing? Just ask!"
        else:
            response = f"üêö **Shelldon** encountered an issue:\n\n"
            response += self.format_script_response(success, filepath)
            response += f"\nüí° Try specifying a different location or check permissions."
        
        return response
    
    def handle_question(self, question: str) -> str:
        """
        Handle non-script questions for Shelldon.
        
        Args:
            question: The question to answer
            
        Returns:
            Expert response
        """
        question_lower = question.lower()
        
        # Skip shell detection if it's likely referring to Shelldon itself in a script request
        if "shelldon" in question_lower and any(word in question_lower for word in ["write", "create", "script"]):
            # This is likely a script request mentioning Shelldon, not a shell question
            return self._handle_general_shell_question(question)
        
        # Shell configuration questions (but not if it's about Shelldon writing scripts)
        elif any(word in question_lower for word in ["bash", "zsh", "fish", "default shell"]) or ("shell" in question_lower and "shelldon" not in question_lower):
            return self._handle_shell_question(question)
        
        # Scripting questions  
        elif any(word in question_lower for word in ["automation", "automate", "batch"]):
            return self._handle_scripting_question(question)
        
        # Command-line tools questions
        elif any(word in question_lower for word in ["command", "tool", "utility", "cli"]):
            return self._handle_tools_question(question)
        
        # Process and system questions
        elif any(word in question_lower for word in ["process", "system", "monitor", "performance"]):
            return self._handle_system_question(question)
        
        # File operations questions
        elif any(word in question_lower for word in ["file", "directory", "find", "search", "permission"]):
            return self._handle_file_question(question)
        
        # General shell questions
        else:
            return self._handle_general_shell_question(question)
    
    def _handle_shell_question(self, question: str) -> str:
        """Handle shell configuration and setup questions."""
        current_shell = os.environ.get('SHELL', 'Unknown')
        system_info = self.get_system_info()
        
        # Check if asking about default shell specifically
        if "default shell" in question.lower() or "is zsh my default" in question.lower():
            return self._check_default_shell()
        
        return f"""üêö **Shelldon** here for shell mastery!

**Current Shell Environment:**
- Active Shell: `{current_shell}`
- Platform: {system_info['platform']}
- User: {system_info['user']}

**üîß Shell Configuration:**

**Check Default Shell:**
```bash
echo $SHELL
# or
getent passwd $USER | cut -d: -f7
```

**Change Default Shell:**
```bash
# List available shells
cat /etc/shells

# Change to zsh
chsh -s $(which zsh)

# Change to bash
chsh -s $(which bash)
```

**‚ö° Popular Shell Setups:**

**Zsh + Oh My Zsh:**
```bash
# Install Oh My Zsh
sh -c "$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"

# Popular plugins in ~/.zshrc
plugins=(git npm node python docker)

# Popular themes
ZSH_THEME="agnoster"  # or "powerlevel10k/powerlevel10k"
```

**Bash Configuration (~/.bashrc):**
```bash
# Custom prompt
export PS1="\\u@\\h:\\w\\$ "

# Aliases
alias ll='ls -la'
alias la='ls -A'
alias grep='grep --color=auto'

# History settings
export HISTSIZE=10000
export HISTCONTROL=ignoredups
```

**üí° Your question:** "{question}"

{self._get_shell_status()}

Want help configuring a specific shell or feature?"""

    def _handle_scripting_question(self, question: str) -> str:
        """Handle shell scripting questions."""
        return f"""üìú **Shelldon** on scripting mastery!

**üöÄ Shell Scripting Essentials:**

**Script Template:**
```bash
#!/bin/bash
set -euo pipefail  # Exit on error, undefined vars, pipe failures

# Variables
readonly SCRIPT_DIR="$(cd "$(dirname "${{BASH_SOURCE[0]}}")" && pwd)"
readonly LOG_FILE="/tmp/script.log"

# Functions
log() {{
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] $*" | tee -a "$LOG_FILE"
}}

main() {{
    log "Script started"
    # Your code here
    log "Script completed"
}}

# Error handling
trap 'log "Script failed on line $LINENO"' ERR

main "$@"
```

**‚ö° Common Patterns:**

**File Processing:**
```bash
# Process files in directory
for file in *.txt; do
    [ -f "$file" ] || continue
    echo "Processing $file"
done

# Find and process
find . -name "*.log" -type f -exec grep -l "ERROR" {{}} \\;
```

**Command Line Arguments:**
```bash
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_help
            exit 0
            ;;
        -v|--verbose)
            VERBOSE=1
            ;;
        *)
            echo "Unknown option: $1"
            exit 1
            ;;
    esac
    shift
done
```

**Error Handling:**
```bash
# Check command success
if command -v git >/dev/null 2>&1; then
    echo "Git is available"
else
    echo "Git not found" >&2
    exit 1
fi

# Function with error checking
safe_mkdir() {{
    local dir="$1"
    if [[ ! -d "$dir" ]]; then
        mkdir -p "$dir" || {{
            echo "Failed to create $dir" >&2
            return 1
        }}
    fi
}}
```

**üí° Your question:** "{question}"

Need help with a specific scripting challenge or pattern?"""

    def _handle_tools_question(self, question: str) -> str:
        """Handle command-line tools questions."""
        return f"""üî® **Shelldon** on command-line tools!

**‚ö° Essential CLI Tools:**

**File Operations:**
```bash
# Advanced find
fd "pattern"          # Modern find alternative
rg "text"             # Modern grep (ripgrep)  
tree                  # Directory visualization
exa                   # Modern ls alternative
bat                   # Better cat with syntax highlighting

# File manipulation
jq '.key'             # JSON processing
yq '.key'             # YAML processing
sed 's/old/new/g'     # Stream editing
awk '{{print $1}}'    # Text processing
```

**System Monitoring:**
```bash
# Process monitoring
htop                  # Interactive process viewer
btop                  # Beautiful system monitor
ps aux | grep nginx   # Process listing

# System resources
df -h                 # Disk usage
du -sh *              # Directory sizes
free -h               # Memory usage
iotop                 # I/O monitoring
```

**Network Tools:**
```bash
# Network diagnostics
curl -I example.com   # HTTP headers
wget -O file.zip url  # Download files
ping google.com       # Network connectivity
netstat -tulpn        # Open ports
ss -tulpn             # Modern netstat

# HTTP testing
httpie GET api.com/users
curl -X POST -H "Content-Type: application/json" -d '{{"key":"value"}}' api.com
```

**Development Tools:**
```bash
# Version control
git status --porcelain
git log --oneline --graph

# Package managers  
npm list --depth=0
pip list --outdated
cargo tree

# Development servers
python -m http.server 8000
php -S localhost:8000
```

**üéØ Modern Replacements:**
- `ls` ‚Üí `exa` or `eza`
- `cat` ‚Üí `bat`
- `find` ‚Üí `fd`
- `grep` ‚Üí `rg` (ripgrep)
- `du` ‚Üí `dust`
- `ps` ‚Üí `procs`

**üí° Your question:** "{question}"

What specific tools or tasks do you need help with?"""

    def _handle_system_question(self, question: str) -> str:
        """Handle system monitoring and administration questions."""
        system_info = self.get_system_info()
        
        return f"""‚öôÔ∏è **Shelldon** on system administration!

**üîç System Monitoring:**

**Performance Overview:**
```bash
# CPU and memory
top -n 1
htop
vmstat 1 5

# Disk I/O
iostat -x 1
iotop

# Network
iftop
nethogs
ss -tuln
```

**Process Management:**
```bash
# Find processes
ps aux | grep nginx
pgrep -f "python app.py"

# Kill processes
pkill -f "python app.py"
kill -9 $(pgrep nginx)

# Process tree
pstree -p
```

**Resource Usage:**
```bash
# Disk usage
df -h /
du -sh /var/log/*
ncdu /home  # Interactive disk usage

# Memory analysis  
free -h
cat /proc/meminfo
slabtop

# CPU info
lscpu
cat /proc/cpuinfo
```

**Log Analysis:**
```bash
# System logs
journalctl -f                    # Follow systemd logs
journalctl -u nginx.service      # Service-specific logs
tail -f /var/log/syslog          # Traditional logs

# Log analysis
grep -i error /var/log/messages
awk '/ERROR/ {{print $1, $2, $NF}}' app.log
```

**üìä Current System:**
- Platform: {system_info['platform']} {system_info['platform_release']}
- Architecture: {system_info['architecture']}
- Python: {system_info['python_version']}
- Load: {self._get_system_load()}

**üí° Your question:** "{question}"

{self._get_process_info()}

Need help with specific system monitoring or administration tasks?"""

    def _handle_file_question(self, question: str) -> str:
        """Handle file operations questions."""
        system_info = self.get_system_info()
        
        return f"""üìÅ **Shelldon** on file operations!

**üîç File Finding & Searching:**

**Modern Tools:**
```bash
# Find files by name (fast)
fd "pattern"
fd "*.py" src/

# Search file contents (blazing fast)
rg "function.*user"
rg "TODO|FIXME" --type python

# Interactive searching
fzf  # Fuzzy finder
```

**Traditional Tools:**
```bash
# Find files
find . -name "*.txt" -type f
find /var -size +100M -exec ls -lh {{}} \\;
find . -mtime -7  # Modified in last 7 days

# Search contents
grep -r "pattern" .
grep -n "error" *.log
```

**üìù File Operations:**

**Basic Operations:**
```bash
# Copy with progress
rsync -av --progress source/ dest/
cp -r --preserve=all source dest

# Move/rename
mv old_name new_name
rename 's/old/new/g' *.txt

# Create/touch
mkdir -p path/to/deep/directory
touch file{{1..10}}.txt
```

**Permission Management:**
```bash
# View permissions
ls -la
stat filename

# Change permissions
chmod 755 script.sh      # rwxr-xr-x
chmod u+x script.sh      # Add execute for user
chmod -R 644 directory/  # Recursive

# Change ownership
chown user:group file
chown -R www-data:www-data /var/www/
```

**üîß Advanced File Operations:**
```bash
# Compare files
diff file1 file2
comm -23 file1 file2     # Lines in file1 but not file2

# File compression
tar -czf archive.tar.gz directory/
tar -xzf archive.tar.gz

# Disk usage
du -sh * | sort -rh      # Sort by size
```

**üìä Current Directory:**
- Location: {system_info['current_dir']}
- User: {system_info['user']}

**üí° Your question:** "{question}"

What specific file operation do you need help with?"""

    def _handle_general_shell_question(self, question: str) -> str:
        """Handle general shell questions."""
        current_shell = os.environ.get('SHELL', 'Unknown')
        system_info = self.get_system_info()
        
        return f"""üéØ **Shelldon** - Your Command-Line Sensei!

I live and breathe the command line! Here's what I can help you with:

**üêö My Specialties:**
- **Shell Mastery** - bash, zsh, fish configuration
- **Scripting Excellence** - automation and workflow scripts  
- **CLI Tools** - modern alternatives and power tools
- **System Administration** - monitoring, processes, logs
- **File Wizardry** - finding, processing, managing files

**‚ö° Quick Wins:**

**Productivity Aliases:**
```bash
alias ll='ls -la'
alias ..='cd ..'
alias ...='cd ../..'
alias grep='grep --color=auto'
alias h='history'
alias c='clear'
```

**One-Liners:**
```bash
# Find large files
find . -type f -size +100M -exec ls -lh {{}} \\; | sort -k5 -rh

# Process monitoring
ps aux | awk '{{print $2, $4, $11}}' | column -t

# Network connections
netstat -tulpn | grep :80
```

**üìä Your Current Setup:**
- Shell: `{current_shell}`
- Platform: {system_info['platform']}
- Working Directory: `{system_info['current_dir']}`

**üí° Your question:** "{question}"

I'm here to make your terminal experience legendary! Whether you need:
- Shell configuration help
- Scripting assistance  
- Command-line tool recommendations
- System administration guidance
- File operation wizardry

**ü§ù Team Synergy:** I work perfectly with:
- **MiseMaster** - For development environment commands
- **TzviTheWindowsWizard** - For cross-platform shell workflows
- **BillTheCoordinator** - For scripted automation workflows

What command-line challenge can I help you conquer?"""

    def _check_default_shell(self) -> str:
        """Check if zsh is the default shell."""
        current_shell = os.environ.get('SHELL', '')
        user = os.environ.get('USER', 'unknown')
        
        # Try to get the user's default shell from passwd
        try:
            passwd_output = subprocess.run(
                ['getent', 'passwd', user], 
                capture_output=True, 
                text=True, 
                timeout=5
            )
            if passwd_output.returncode == 0:
                shell_from_passwd = passwd_output.stdout.strip().split(':')[-1]
            else:
                shell_from_passwd = "Unknown"
        except (subprocess.CalledProcessError, subprocess.TimeoutExpired, FileNotFoundError):
            shell_from_passwd = "Unknown"
        
        is_zsh = 'zsh' in current_shell.lower()
        
        return f"""üêö **Shelldon** checking your shell status!

**üîç Shell Analysis:**
- **Current Session Shell:** `{current_shell}`
- **Default Shell (from passwd):** `{shell_from_passwd}`
- **Is zsh your default?** {'‚úÖ Yes!' if is_zsh else '‚ùå No'}

**üìä Shell Status:**
```
Current: {current_shell}
Default: {shell_from_passwd}
Match: {'‚úÖ Yes' if current_shell == shell_from_passwd else '‚ö†Ô∏è  Different'}
```

**üîß To Make zsh Your Default:**
```bash
# Check available shells
cat /etc/shells

# Change default shell to zsh  
chsh -s $(which zsh)

# Verify change
echo $SHELL
```

**‚ö° After Changing Shell:**
1. **Log out and back in** for changes to take effect
2. **Install Oh My Zsh** for an enhanced experience:
   ```bash
   sh -c "$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"
   ```

{'**üéâ You are already using zsh as your default shell!**' if is_zsh else '**üí° Switch to zsh for a more powerful shell experience!**'}"""

    def _get_shell_status(self) -> str:
        """Get current shell status and configuration."""
        current_shell = os.environ.get('SHELL', 'Unknown')
        shell_name = Path(current_shell).name if current_shell != 'Unknown' else 'Unknown'
        
        status_lines = [
            f"- Active Shell: `{current_shell}`",
            f"- Shell Name: `{shell_name}`"
        ]
        
        # Check for common shell config files
        home = Path.home()
        configs = {
            'bash': ['.bashrc', '.bash_profile', '.profile'],
            'zsh': ['.zshrc', '.zprofile'],
            'fish': ['.config/fish/config.fish']
        }
        
        for shell_type, config_files in configs.items():
            for config_file in config_files:
                config_path = home / config_file
                if config_path.exists():
                    status_lines.append(f"- {shell_type.title()} Config: `{config_path}` ‚úÖ")
        
        return "\n**üîç Shell Status:**\n" + "\n".join(status_lines)

    def _get_system_load(self) -> str:
        """Get system load average if available."""
        try:
            with open('/proc/loadavg', 'r') as f:
                load = f.read().strip().split()[:3]
                return f"{load[0]} {load[1]} {load[2]}"
        except FileNotFoundError:
            return "N/A"

    def _get_process_info(self) -> str:
        """Get basic process information."""
        try:
            # Get process count
            ps_output = subprocess.run(['ps', 'aux'], capture_output=True, text=True)
            if ps_output.returncode == 0:
                process_count = len(ps_output.stdout.strip().split('\n')) - 1
                return f"\n**üî¢ Process Count:** {process_count} running processes"
        except FileNotFoundError:
            pass
        
        return "\n**üî¢ Process Info:** Not available on this system"